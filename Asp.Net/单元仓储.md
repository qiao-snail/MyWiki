# Asp.Net MVC - 单元仓储模式

## 仓储模式

通常不建议在业务逻辑层直接访问数据库。因为这样可能会导致如下结果：

* 重复的代码
* 编程错误的可能性更高
* 业务数据的弱类型
* 在集中化数据相关策略方面的困难，比如缓存？
* 无法轻松地从外部依赖项测试业务逻辑

在业务逻辑层通过仓库模式则可以实现如下特点：

* 您希望最大化可以用自动化测试的代码量，并隔离数据层以支持单元测试。
* 您可以从许多位置访问数据源，并希望应用集中管理的、一致的访问规则和逻辑。
* 您需要为数据源实现和集中一个缓存策略。
* 您希望通过将业务逻辑与数据或服务访问逻辑分隔开，从而提高代码的可维护性和可读性。
* 您需要使用强类型的业务实体以便在编译时识别问题而不是在运行时

使用仓储模式是为了分离业务层和数据源层，并把业务层的Model和数据源层的Model相互映射。（ViewModel和Entity之间的映射）。即业务逻辑层应该和数据源层无关，数据源层的源的更改不影响业务逻辑层。

数据源层和业务层之间的分离有三个好处:

* 集中了数据逻辑或Web服务访问逻辑。
* 为单元测试提供了一个替代点。
* 提供了一种灵活的体系结构，可以作为应用程序的整体设计进行调整。

## 一、定义仓储接口

```CSharp
  /// <summary>
    /// 定义仓储模型中的数据标准操作
    /// </summary>
    /// <typeparam name="TEntity">动态实体类型</typeparam>
    public interface IRepository<TEntity> where TEntity : class
    {
        #region 属性

        /// <summary>
        /// 获取 当前实体的查询数据集
        /// </summary>
        IQueryable<TEntity> Entities { get; }

        #endregion

        #region 公共方法

        /// <summary>
        /// 插入实体记录
        /// </summary>
        /// <param name="entity"> 实体对象 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Insert(TEntity entity, bool isSave = true);

        /// <summary>
        /// 批量插入实体记录集合
        /// </summary>
        /// <param name="entities"> 实体记录集合 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Insert(IEnumerable<TEntity> entities, bool isSave = true);

        /// <summary>
        /// 删除指定编号的记录
        /// </summary>
        /// <param name="id"> 实体记录编号 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(object id, bool isSave = true);

        /// <summary>
        /// 删除实体记录
        /// </summary>
        /// <param name="entity"> 实体对象 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(TEntity entity, bool isSave = true);

        /// <summary>
        /// 删除实体记录集合
        /// </summary>
        /// <param name="entities"> 实体记录集合 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(IEnumerable<TEntity> entities, bool isSave = true);

        /// <summary>
        /// 删除所有符合特定表达式的数据
        /// </summary>
        /// <param name="predicate"> 查询条件谓语表达式 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(Expression<Func<TEntity, bool>> predicate, bool isSave = true);

        /// <summary>
        /// 更新实体记录
        /// </summary>
        /// <param name="entity"> 实体对象 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Update(TEntity entity, bool isSave = true);

        /// <summary>
        /// 查找指定主键的实体记录
        /// </summary>
        /// <param name="key"> 指定主键 </param>
        /// <returns> 符合编号的记录，不存在返回null </returns>
        TEntity GetByKey(object key);

        #endregion
    }
```

### 二、实现泛型仓储基类

```CSharp

```

### 三、访问数据

在EF数据上下文中，通过泛型仓储基类访问数据。

```CSharp

```
---

总结：

总之仓储模式是为了业务和数据访问之间的隔离，及数据访问的一致性。

---

## 工作单元模式

>工作单元模式是“维护一个被业务事务影响的对象列表，协调变化的写入和并发问题的解决”

比如：新入校一个同学，需要在班级，学校，学生，课程等多个表里同时操作。这些表要么都完成，要么都不完成。一致性。

在仓储模式中使用工作单元模式是为了当你有用到多个仓储时，共用一个数据上下文（DbContext）。当保存到数据库时，使得在同一个上下文的这些仓储可以同时保存。

在Entity Framework中可以把DbContext当作是一个工作单元。当然如果要对工作单元扩展的话（记录每个操作等），可以自定义一个工作单元。

### 自定义工作单元

#### 一、定义IUnitOfWork接口

```CSharp
/// <summary>
/// 工作单元接口
/// </summary>
public interface IUnitOfWork
{
    #region 方法

    /// <summary>
    /// 保存当前单元操作的结果
    /// </summary>
    /// <returns></returns>
    void Save();

}
```

#### 二、定义UnitOfWork类

UnitOfWork包含了所有的仓储，及一个数据上下文，继承IDisposable接口（在此释放数据上下文）。

```CSharp

public class UnitOfWork : IUnitOfWork, IDisposable
{
    private WMSEFContext context = new WMSEFContext();
    private EFRepositoryBase<wareposition> _warepositionRepository;
    private EFRepositoryBase<warehouse> _warehouseRepository;
    private EFRepositoryBase<warehousecirculation> _warehouseCirculationRepository;
    private EFRepositoryBase<shelfinfolist> _shelfRepository;
    private EFRepositoryBase<materialstype> _bomRepository;
    private EFRepositoryBase<warehousealarmlist> _warnRepository;
    private EFRepositoryBase<warehousecirculation> _circuleRepository;
    /// <summary>
    /// 仓库仓储
    /// </summary>
    public EFRepositoryBase<warehouse> WarehouseRepository
    {
        get
        {
            return _warehouseRepository ?? new EFRepositoryBase<warehouse>(context);
        }
    }
    /// <summary>
    /// 库位仓库
    /// </summary>
    public EFRepositoryBase<wareposition> WarepositionRepository
    {
        get
        {
            return _warepositionRepository ?? new EFRepositoryBase<wareposition>(context);
        }
    }
    /// <summary>
    /// 流转仓库
    /// </summary>
    public EFRepositoryBase<warehousecirculation> WarehouseCirculationRepository
    {
        get
        {
            return _warehouseCirculationRepository ?? new EFRepositoryBase<warehousecirculation>(context);
        }
    }
    /// <summary>
    /// 货架
    /// </summary>
    public EFRepositoryBase<shelfinfolist> ShelfRepository
    {
        get
        {
            return _shelfRepository ?? new EFRepositoryBase<shelfinfolist>(context);
        }
    }
    /// <summary>
    /// 物料
    /// </summary>
    public EFRepositoryBase<materialstype> BomRepository
    {
        get
        {
            try
            {
                return _bomRepository ?? new EFRepositoryBase<materialstype>(context);

            }
            catch (Exception ex)
            {

                throw;
            }
        }
    }
    /// <summary>
    /// 报警日志
    /// </summary>

    public EFRepositoryBase<warehousealarmlist> WarnRepository
    {
        get { return _warnRepository ?? new EFRepositoryBase<warehousealarmlist>(context); }
    }


    public EFRepositoryBase<warehousecirculation> CirculeRepository
    {
        get
        {
            return _circuleRepository ?? new EFRepositoryBase<warehousecirculation>(context);
        }
    }

    public void Save()
    {
        context.SaveChanges();
    }

    private bool disposed = false;

    protected virtual void Dispose(bool disposing)
    {
        if (!this.disposed)
        {
            if (disposing)
            {
                context.Dispose();
            }
        }
        this.disposed = true;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    // public void Rollback()
    // {
    //     context.ChangeTracker.Entries().ToList().ForEach(x => x.Reload());
    // }
}

```

#### 三、使用实例

```CSharp

public ActionResult GetStud()
{
    using(UnitOfWork unit=new UnitOfWork())
    {
        var result=unit.WarehouseRepository.Get().ToList();
        return View(result);
    }
}
```
