# Asp.Net MVC - 单元仓储模式

## 仓储模式

通常不建议在业务逻辑层直接访问数据库。因为这样可能会导致如下结果：

* 重复的代码
* 编程错误的可能性更高
* 业务数据的弱类型
* 在集中化数据相关策略方面的困难，比如缓存？
* 无法轻松地从外部依赖项测试业务逻辑

在业务逻辑层通过仓库模式则可以实现如下特点：

* 您希望最大化可以用自动化测试的代码量，并隔离数据层以支持单元测试。
* 您可以从许多位置访问数据源，并希望应用集中管理的、一致的访问规则和逻辑。
* 您需要为数据源实现和集中一个缓存策略。
* 您希望通过将业务逻辑与数据或服务访问逻辑分隔开，从而提高代码的可维护性和可读性。
* 您需要使用强类型的业务实体以便在编译时识别问题而不是在运行时

使用仓储模式是为了分离业务层和数据源层，并把业务层的Model和数据源层的Model相互映射。（ViewModel和Entity之间的映射）。即业务逻辑层应该和数据源层无关，数据源层的源的更改不影响业务逻辑层。

数据源层和业务层之间的分离有三个好处:

* 集中了数据逻辑或Web服务访问逻辑。
* 为单元测试提供了一个替代点。
* 提供了一种灵活的体系结构，可以作为应用程序的整体设计进行调整。

## 一、定义仓储接口

```CSharp
  /// <summary>
    /// 定义仓储模型中的数据标准操作
    /// </summary>
    /// <typeparam name="TEntity">动态实体类型</typeparam>
    public interface IRepository<TEntity> where TEntity : class
    {
        #region 属性

        /// <summary>
        /// 获取 当前实体的查询数据集
        /// </summary>
        IQueryable<TEntity> Entities { get; }

        #endregion

        #region 公共方法

        /// <summary>
        /// 插入实体记录
        /// </summary>
        /// <param name="entity"> 实体对象 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Insert(TEntity entity, bool isSave = true);

        /// <summary>
        /// 批量插入实体记录集合
        /// </summary>
        /// <param name="entities"> 实体记录集合 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Insert(IEnumerable<TEntity> entities, bool isSave = true);

        /// <summary>
        /// 删除指定编号的记录
        /// </summary>
        /// <param name="id"> 实体记录编号 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(object id, bool isSave = true);

        /// <summary>
        /// 删除实体记录
        /// </summary>
        /// <param name="entity"> 实体对象 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(TEntity entity, bool isSave = true);

        /// <summary>
        /// 删除实体记录集合
        /// </summary>
        /// <param name="entities"> 实体记录集合 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(IEnumerable<TEntity> entities, bool isSave = true);

        /// <summary>
        /// 删除所有符合特定表达式的数据
        /// </summary>
        /// <param name="predicate"> 查询条件谓语表达式 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Delete(Expression<Func<TEntity, bool>> predicate, bool isSave = true);

        /// <summary>
        /// 更新实体记录
        /// </summary>
        /// <param name="entity"> 实体对象 </param>
        /// <param name="isSave"> 是否执行保存 </param>
        /// <returns> 操作影响的行数 </returns>
        int Update(TEntity entity, bool isSave = true);

        /// <summary>
        /// 查找指定主键的实体记录
        /// </summary>
        /// <param name="key"> 指定主键 </param>
        /// <returns> 符合编号的记录，不存在返回null </returns>
        TEntity GetByKey(object key);

        #endregion
    }
```

### 二、实现泛型仓储基类

```CSharp

```

### 三、访问数据

在EF数据上下文中，通过泛型仓储基类访问数据。

```CSharp

```
---

总结：

总之仓储模式是为了业务和数据访问之间的隔离，及数据访问的一致性。

---

## 工作单元模式

工作单元模式是“维护一个被业务事务影响的对象列表，协调变化的写入和并发问题的解决”

在Entity Framework中DbContext可以认为是一个工作单元。

当然如果你要对事务扩展的话，就要自定义一个工作单元。

工作单元模式是为了当你有用到多个仓储时，共用一个context。当调用SaveChanges()方法时，使得在同一个上下文的仓储可以同时保存。

## 为什么要用单元仓储模式

单元仓储模式在数据访问层和应用程序的业务逻辑层中间添加了一个抽象层。使得业务逻辑层不需要关心数据存储的细节。实现该模式可以帮助我们免受数据存储的的更改，并且可以更方便的实现单元测试和测试驱动开发。

