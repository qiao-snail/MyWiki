# Asp.Net MVC 缓存

> 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝。

>Web应用缓存技术大体上可以分为两类:服务端缓存和客户端缓存。两种目标都是减少重复性内容的生成和网络传输工作，因为缓存数据存储的位置不同，而分为服务端缓存和客户端缓存。

* 304 200区别

* 客户端缓存的有效性，刷新，跳转

* no-cach和no-store区别
* 页面缓存 数据缓存

## 服务端缓存

> 服务端缓存技术关注于服务端数据查询，生成或者操作技术。主要就是减少处理请求的工作量，减少数据库查询次数和生成HTML数据的CPU周期--减少每个bit的数据。
对于服务端缓存来说，不管是刷新页面，重新输入地址，还是Control+F5都不会规避缓存，如果缓存数据有效，一定是请求的缓存数据。

### 输出缓存(Output Cache)

输出缓存是Asp.Net下更高级更好用的缓存机制。输出缓存，缓存请求生成的HTML数据--缓存Action下返回数据（Html/Json）。这样，在每次调用相同的控制器动作时，就不需要再次生成相同的内容。

#### 缓存位置（Location）

`OutputCache`使缓存的内容一般放在三个位置上：服务端，代理服务器，浏览器客户端。通过`Loaction`属性可以设置缓存的位置。

`Loaction`属性有如下值：

* Any
* Client
* Downstream
* Server
* None
* ServerAndClient

默认值为`Any`，就是在三个位置都会缓存。但是应该根据不同的情况使用不同的缓存位置。比如：要缓存的内容是针对特定用户的，每个用户都会不同。这样的话，该缓存就不能保存在服务器上。应该保存在浏览器客户端上。


#### 使用Output Cache

在Controller或者Action上添加`[OutputCache]`特性，使得被添加的Controller或Action可以缓存返回的数据。

如下代码:当第一次方法该Action时，开始计时10秒，此10秒内所有访问该Action的请求都会请求缓存数据。当10秒结束后，再重新开始等待新一次请求，开始新的10秒缓存。就是**每隔10秒更新一次缓存数据**。

```CSharp
using System.Web.Mvc;
using System.Web.UI；

namespace MvcApplication1.Controllers
{
    public class HomeController : Controller
    {
        [OutputCache(Duration=10, VaryByParam="none"， Location = OutputCacheLocation.Server)]
        public ActionResult Index()
        {
            return View();
        }
    }
}
```

View:

```Html
@{
    ViewBag.Title = "Index";
}

<h2>Index</h2>

<p>@DateTime.Now.ToString()</p>

```
点击F12,查看请求

![缓存](imgs/servercache.png)

Cache-Control:no-cache,
Expire=-1,
都表示客户端没有缓存。

需要注意的是

1. 该缓存时间是绝对时间。
2. 此缓存是对所有访问该页面的用户都有效。
3. 不能保证缓存一定有效。当内存资源不够时，缓存就会自动地将没用的或者优先级低缓存清除。

---


## 客户端缓存

除了服务端缓存内容以外，客户端也可以缓存数据。它避免了向服务器重复提交获取重复数据的请求次数，把一些重复数据缓存到本地。服务端缓存技术的目标是为了更快的处理完客户端请求，而客户端缓存的目标则是为了避免不必要的请求。

我们来指定Location值为`OutputCacheLocation.Client`。使缓存在浏览器客户端上。

```CSharp
using System.Web.Mvc;
using System.Web.UI;

namespace MvcApplication1.Controllers
{
    public class BadUserController : Controller
    {
        [OutputCache(Duration = 10, VaryByParam = "none",Location = OutputCacheLocation.Client)]
        public ActionResult ClientCache()
        {
            return View();
        }
    }
}
```

```Html
@{
    ViewBag.Title = "ClientCache";
}

<h2>ClientCache</h2>

<p>@DateTime.Now.ToString()</p>
```

客户端缓存和服务端缓存不一样，刷新，重新输入地址，和Control+F5都会破坏客户端缓存，从服务端重新获取数据。

那么什么情况下客户端缓存才有效？

通过URL访问，客户端缓存才有效。

比如：

1. 页面A是客户端缓存，同时页面A有一个跳向页面B的链接。
2. 通过A到达页面B，同时页面B也有一个链接，这个链接调向A。
3. 通过B再次访问A，此时页面A访问的数据客户端的缓存数据，并没有请求服务端，是没有请求服务端。不是304。

这时候必要说清楚什么时候才是304,304和200（cache）又有什么区别？

1. 304

只有当客户端和服务端同时都缓存了数据。且缓存没有更新的时候，才会有304。即这个缓存是要到服务端验证，是否需要更新缓存。如果要更新缓存status code：200，否则status code：304.

2. 304 和200（from cache)区别

304是会到服务端去校验一次当前客户端缓存是否有效。而200（from cache）则没有向服务端校验，也没有向服务端请求，直接使用了客户端缓存。那么如何避免这种，没有向服务端请求，直接使用缓存的情况，就是更改这个缓存的url。添加一个版本号或唯一值。这样因为url的更改是得在客户端没有对应的url缓存，就会从服务端重新获取，再缓存。

--- 

### 不同的输出缓存

在某些情况下，您可能需要不同的相同内容的缓存版本。例如，假设您正在创建一个主/详细页面。主页显示了一个电影标题列表。当你点击标题时，你会得到所选影片的详细信息。

如果您缓存了details页面，那么不管您点击哪个电影，相同电影的细节都会显示出来。第一个用户选择的第一个电影将显示给所有未来的用户。

您可以利用OutputCache属性的VaryByParam属性来解决这个问题。当表单参数或查询字符串参数变化时，该属性使您能够创建完全相同的内容的不同缓存版本。

```CSharp
using System.Linq;
using System.Web.Mvc;
using MvcApplication1.Models;

namespace MvcApplication1.Controllers
{
    public class MoviesController : Controller
    {
        private MovieDataContext _dataContext;

        public MoviesController()
        {
            _dataContext = new MovieDataContext();
        }

        [OutputCache(Duration=int.MaxValue, VaryByParam="none")]
        public ActionResult Master()
        {
            ViewData.Model = (from m in _dataContext.Movies 
                              select m).ToList();
            return View();
        }

        [OutputCache(Duration = int.MaxValue, VaryByParam = "id")]
        public ActionResult Details(int id)
        {
            ViewData.Model = _dataContext.Movies.SingleOrDefault(m => m.Id == id);
            return View();
        }


    }
}
```

Details()操作包括一个带有值“Id”的VaryByParam属性。当将Id参数的不同值传递给控制器操作时，将生成详细信息视图的不同缓存版本。

重要的是要理解使用VaryByParam属性会导致更多的缓存，而不是更少。为每个不同版本的Id参数创建了一个不同的细节视图的缓存版本。

VaryByParam的特性：

* "*"每当表单或查询字符串参数变化时，创建一个不同的缓存版本。
* "none" 永远不要创建不同的缓存版本。
* “参数列表” 为不同的参数创建不同的缓存版本。

---

Output Cache是Asp.Net 缓存中很重要的一个机制。


### 创建缓存简介

可以通过修改OutputCache属性的属性来配置输出缓存属性，您可以在web配置(web.config)文件中创建一个缓存配置文件。在web配置文件中创建缓存配置文件提供了一些重要的优势。

首先，通过在web配置文件中配置输出缓存，您可以控制在一个中心位置中控制器操作缓存内容的方式。您可以创建一个缓存概要文件，并将概要文件应用到几个控制器或控制器操作。

其次，您可以修改web配置文件，而无需重新编译应用程序。如果您需要为已经部署到生产环境中的应用程序禁用缓存，那么您可以简单地修改web配置文件中定义的缓存配置文件。对web配置文件的任何更改都将被自动检测并应用。

例如，清单6中的web配置部分定义了一个名为cache1时针的缓存配置文件。部分必须在小于系统中出现。web配置文件的一部分。

```xml
<caching>
<outputCacheSettings>
    <outputCacheProfiles>
        <add name="Cache1Hour" duration="3600" varyByParam="none"/>
    </outputCacheProfiles>
</outputCacheSettings>
</caching>
```

```CSharp
using System;
using System.Web.Mvc;

namespace MvcApplication1.Controllers
{
    public class ProfileController : Controller
    {
        [OutputCache(CacheProfile="Cache1Hour")]
        public string Index()
        {
            return DateTime.Now.ToString("T");
        }
    }
}
```

---

简单介绍下缓存的头相关信息：

* cache-control: no-store no-cache private public 
 no-store 表示不在任何地方保存，可以理解为强制不缓存。

 no-cache 表示每次请求都要需要到服务端校验，并更新客户端的缓存，

 private 表示在浏览器端缓存

 public 表示可以在浏览器，代理等多个地方缓存。

 * Expires


|消息头|值|类型|说明
|---|---|-----|---|
|Expires|Thu, 30 Nov 2017 08:21:14 GMT|响应|过期时间，为格林威治时间 (GMT)|
|Pragma|no-cache|响应|忽略浏览器缓存（Http1.1用Cache-Control代替）|
|Cache-Control|no-cache|响应|忽略浏览器缓存|
| |no-store|响应|不在任何地方保存数据，不缓存数据|
|  |max-age=[秒]|响应|设置浏览器缓存最长时间|
|  |public|响应|缓存在任何地方|
|  |private|响应|缓存该用户的浏览器|
|Last-Modified |Thu, 30 Nov 2017 08:21:14 GMT|响应|告诉浏览器服务端最后一次修改的时间|
|If-Modified-Since |Thu, 30 Nov 2017 08:21:14 GMT|请求|如果浏览器中Last-Modofied有值，在请求中把值给If-Modified-Since,提交给服务端|
|ETag|3df04c15b968d31:0|响应|该资源及其版本在服务端的唯一标识|
|If-None-Match|3df04c15b968d31:0|请求|把上次请求中获取到的ETag值，赋值给If-None-Match并提交给服务端|
|Vary|Accept-Encoding|响应|从多个缓存副本中选择匹配的版本|




no-cache: 使用no-cache 指令的目的是为了防止从缓存中返回过期的资源，客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。从字面意思上很容易把no-cache误解成为不缓存，但事实上no-cache代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为do-not-serve-from-cache-without-revalidate更合适。no-cache 才是真正地不进行缓存，请读者注意区别理解。
must-revalidate: 可缓存但必须再向源服务器进行确认。
no-store: 暗示请求（和对应的响应）或响应中包含机密信息，该指令规定缓存不能在本地存储请求或响应的任一部分。