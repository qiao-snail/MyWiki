# 线程同步
上一篇介绍了如何开启线程，线程间相互传递参数，及本地变量和全局共享变量。
本篇主要说明**线程同步**。

线程同步的方法简单概括主要有四种：
* 阻塞方法（blocking methods）

 *使用 Sleep,Join,Task.Wait等待另一个线程结束，或时等待一段时间*
* 加锁

 *使用lock,Mutex,SpinLock,reader/writer locks使多个线程同一时间只有一个线程执行，其他线程等待，同时可以在多线程间共享变量*
* 信号

*使用 event wait handles, Wait/Pause当从另一个线程中获取到状态标记时该线程再执行，否则一直处于阻塞状态。*
* 非阻塞同步构造

*使用Thread.MemoryBarrier,Thread.VolatileRead,Thread.VolatileWrite,volatile,Interlocked通过对处理器的限制来保护那些共享字段*

## 阻塞
当该方法的线程调用Sleep，或者另一个线程调用Join，EndInvoke，该方法就处于阻塞状态。当该方法处于阻塞状态时，立即从cpu退出。（阻塞状态的线程不消耗cpu）
当线程在阻塞和非阻塞状态间切换时会消耗几毫秒时间。
``` CSharp
//Join
static void Main()
{
  Thread t = new Thread (Go);
  Console.WriteLine ("Main方法已经运行....");  
  t.Start();
  t.Join();//阻塞Main方法
  Console.WriteLine ("Main方法解除阻塞，继续运行...");
}
 
static void Go()
{
  Console.WriteLine ("阻塞Main方法，在t线程上运行Go方法..."); 
}

//Sleep
static void Main()
{
  Console.WriteLine ("Main方法已经运行....");  
  Thread.CurrentThread.Sleep(3000);//阻塞当前线程
  Console.WriteLine ("Main方法解除阻塞，继续运行...");
}
 
 //Task
 static void Main()
{
   Task Task1=Task.Run(() => {  
            Console.WriteLine("task方法执行..."); 
            }); 
   Task1.Wait();//阻塞当前线程 
   Console.WriteLine(Task1.IsCompleted); 
}
```
## 加锁（lock）

加锁使多个线程同一时间只有一个线程进入该方法，其他线程等待给线程释放该方法。
* lock关键字简单高效
* Mutex是多个进程间的加锁。
``` CSharp
class ThreadSafe
{
  static readonly object _locker = new object();
  static int _val1, _val2;
 
  static void Go()
  {
    lock (_locker)
    {
      if (_val2 != 0) Console.WriteLine (_val1 / _val2);
      _val2 = 0;
    }
  }
}
```

| 方法 | 描述 | 跨进程 | 
|----|---|----|---|
|lock (Monitor.Enter / Monitor.Exit) | 确保一次只有一个线程访问一个资源或代码| No|
|Mutex | 确保一次只有一个线程访问一个资源或代码|Yes|
|Semaphore|确保不大于指定个数的访问资源或代码段的并发线程|Yes|
|ReaderWriterLock (effectively deprecated)|允许一个writter和多个readder|No|

**同步对象的选择：**
* 引用类型
* pivate 修饰
* 静态字段或实例

或者
* 关键字this
* 类型（typeof(T)）

*同步对象可以兼作它保护的对象*
如：
``` CSharp
class ThreadSafe
{
  List <string> _list = new List <string>(); 
  void Test()
  {
    lock (_list)
    {
      _list.Add ("Item 1");
    }
  }
}
```

``` CSharp
lock (this) { ... }
```

``` CSharp
lock (typeof (类实例)) { ... }  
```
**在共享字段的修改的地方加锁**
如：
``` CSharp
class ThreadSafe
{
  static readonly object _locker = new object();
  static int _x;
 
  static void Increment() { lock (_locker) _x++; }
  static void Assign()    { lock (_locker) _x = 123; }
}
```

**死锁**
当两个线程在同时等待对方的锁的释放的时候就会产生死锁。
如：
``` CSharp
object locker1 = new object();
object locker2 = new object();
 
new Thread (() => {
                    lock (locker1)
                    {
                      Thread.Sleep (1000);
                      lock (locker2);      // Deadlock
                    }
                  }).Start();
lock (locker2)
{
  Thread.Sleep (1000);
  lock (locker1);                          // Deadlock
}
```
