# 如何检测和避免.NET应用程序中的内存和资源泄漏

尽管很多人相信，在.NET应用程序中很容易引入内存和资源泄漏。但是垃圾收集器(即亲密伙伴的GC)并不是一个可以完全消除您的内存和资源消耗的魔术师。

我将在这篇文章中解释为什么.NET中存在内存泄漏以及如何避免它们。别担心，我不会在这里集中讨论垃圾收集器的内部工作方式以及.NET中内存和资源管理的其他高级特性。

了解泄漏以及如何避免泄漏，特别是那种容易被自动检测到的东西,是很重要的。单元测试在这里不起作用。当您的应用程序在生产环境中崩溃时，您将急于寻找解决方案。所以，放轻松，在一切还不太晚之前，花点时间多了解一下这个主题。

## 介绍

最近，我一直在从事一个大型的.NET项目(暂称为X项目)，我的职责之一就是跟踪内存和资源泄漏。我主要关注与GUI相关的泄漏，更准确地说，是在基于复合UI应用程序块(CAB)的Windows窗体应用程序中。
虽然我在这里展示的一些信息直接适用于Windows窗体，但是大多数要点同样适用于任何类型的.NET应用程序(WPF、Silverlight、ASP)。NET、Windows服务、控制台应用程序等)

在此之前，我并不是一个寻找泄漏的专家。本文的目的是与您分享我在这个过程中学到的东西。希望它对需要检测和修复内存和资源泄漏的任何人都有用。我们将首先概述什么是泄漏，然后我们将看到如何检测泄漏并找到泄漏的资源，如何解决和避免泄漏，最后我们将列出有用的工具和资源。

## 资源泄露？到底是什么？

### 内存泄漏

在进一步讨论之前，让我们先看下什么是“内存泄漏”。让我们简单地复用一下Wikipedia中的定义。它完全符合这篇文章的需求:

 > 在计算机科学中，内存泄漏是计算机程序在不再需要内存时却无法释放的一种特殊类型的意外内存消耗。这种情况通常是程序中的一个bug导致的，该bug阻止程序释放不再需要的内存。


Wikipedia中还提到:“提供自动内存管理的语言，如Java、c#和VB.NET或LISP都不能避免内存泄漏。”
垃圾回收器只回收无法访问的内存。它不会释放仍然可访问的内存。在.NET中，这意味着至少有一个引用可以访问的对象不会被垃圾收集器释放。

### 处理和资源

我们不能只盯着内存。当您的.NET应用程序在Windows上运行时，它会消耗一整套系统资源。Microsoft定义了三类系统对象:用户、图形设备接口(GDI)和内核。我不会在这里给出完整的对象列表,只举几个重要的例子:

* 系统使用**用户对象**来支持窗口管理。它们包括:加速表、插入符号、光标、挂钩、图标、菜单和窗口。
* GDI对象支持图形:位图、笔刷、设备上下文(DC)、字体、内存DCs、元文件、调色板、笔、区域等。
* 内核对象支持内存管理、进程执行和进程间通信(IPC):文件、进程、线程、信号量、计时器、访问令牌、套接字等。


你可以在[MSDN](https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/object-categories?redirectedfrom=MSDN)上找到系统对象的所有详细信息。

除了系统对象之外，还会遇到句柄。如MSDN所述，应用程序不能直接访问对象数据或对象所代表的系统资源。相反，应用程序必须获得一个对象句柄，它可以使用该句柄来检查或修改系统资源。

但是，在.NET，这在大多数情况下是透明的，因为系统对象和句柄是由.NET类直接或间接表示的。

### 未托管资源

诸如系统对象之类的资源本身并不是问题，但是我在本文中还要讨论它们，因为诸如Windows之类的操作系统对可以同时打开的套接字、文件等的数量有限制。这就是为什么要注意应用程序使用的系统对象的数量。

Windows对进程在给定时间可以使用的用户和GDI对象的数量有配额。默认值为10,000 (GDI对象)和10,000 (User对象)。如果需要读取机器上设置的值，可以使用   

    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows: GDIProcessHandleQuota和USERProcessHandleQuota中的注册表项。

你猜怎么着?它甚至没有那么简单。你还可以很快达到其他极限。例如，请参阅我[关于桌面堆的博客文章](https://weblogs.asp.net/fmarguerie/cannot-create-window-handle-desktop-heap)。

考虑到这些限额可以修改，您可能会觉得提高限额是一个解决方案。但是我认为这是一个坏主意，原因如下:

1. 配额的存在是有原因的:在系统上并不是只运行了您一个应用程序，它应该与机器上运行的其他进程共享系统资源。
2. 如果你修改了配额，有可能会引起其他方面的问题。您必须确保所有跑在系统上的应用程序在修改后，都还可以正常运行。但是从系统管理的角度来看，这几乎不可能。
3. 大多数默认配额的情况下，如果您发现配额不足以满足您的应用程序，那么您可能需要做一些清理工作。


## 如何检测泄漏并找到泄漏的资源

关于GDI代码泄漏的一篇文章很好地说明了泄漏的真正问题:
如果多次发生泄漏，即使是很小的泄漏也会使系统瘫痪。
这与漏水的情况类似。一滴水不是大问题。但是一点一滴地，泄露会成为一个大问题。
正如我稍后将解释的，一个无关紧要的对象可能在内存中维护整个很大的内存对象。
仍然在同一篇文章中，你可以学到:

消除泄漏通常有三个步骤:
1. 检测泄漏
2. 查找泄漏资源
3. 在代码使用何时何处释放资源

检测漏洞最直接的方法就是遭受它们。

你几乎不会看到你的电脑内存不足，这种情况很少发生。这是因为当操作系统用完RAM时，它们会使用硬盘空间来扩展内存工作区(这称为虚拟内存)。

在Windows图形应用程序中，更可能出现的是“out of handle”异常。确切的例外是System.ComponentModel。Win32Exception或系统。带有以下消息的OutOfMemoryException:“创建窗口句柄出错”。当两个资源同时被消耗时就会发生这种情况，这很可能是因为在应该释放对象时却没有释放它们。


另一件你可能经常看到的事情是你的应用程序或整个计算机变得越来越慢。这是因为您的机器正在耗尽资源。

直言不讳地说:大多数应用程序都会泄漏。大多数情况下，这不是问题，因为只有在大量使用应用程序和长时间使用时，才会出现泄漏问题。

如果您怀疑对象在应该被释放的时候还在内存中徘徊，那么您需要做的第一件事就是查找这些对象是什么。

这似乎是显而易见的，但找到这些对象不是那么容易。

我建议您使用您最喜欢的内存分析器来查找未预料到的、持久的高级对象或根容器。在project X中，可以是LayoutView实例之类的对象(我们在CAB/SCSF中使用MVP模式)。在您的例子中，这完全取决于根对象是什么。
下一步是找出为什么这些需要释放却没释放的对象。这就是调试器和分析器真正有用的地方。它们可以向你展示对象是如何连接在一起的。

通过查看已标识的zombie对象的传入引用，您将能够找到问题的根源。
您可以选择遵循ninja方法(参见下面关于工具的部分中的SOS.dll和WinDbg)。
我在项目X中使用了JetBrains dotTrace工具，这也是我将在本文中使用的工具。稍后在下面的工具部分中，我将告诉您关于此工具的更多信息。

您的目标应该是找到根引用。不要停在你找到的第一个对象上，而是问问你自己为什么这个对象被保存在内存中。


## 内存泄露的常见情况

我在上面写过，泄漏在.NET中很常见。好消息是，引起泄露的原因只有一小部分。这意味着，当您试图解决泄漏时，您不必寻找很多案例。

让我们来回顾一下我发现的常见罪魁祸首:

* 静态引用
* 缺少取消订阅的事件
* 缺少取消订阅的静态事件
* 未调用Dispose方法
* 不完整的Dispose方法
  
除了这些经典的陷阱，这里还有其他更具体的问题来源:

* Windows窗体:BindingSource被误用
* CAB:缺少对工作项的移除调用

我刚才列出的罪魁祸首与您的应用程序直接有关，但是在您的应用程序所依赖的其他.NET代码片段或库中也可能发生泄漏。实际上，您使用的库中可能存在bug。

举个例子。在project X中，使用第三方可视化控件套件来构建GUI。其中一个控件用于显示工具栏。它的使用方式是通过一个管理工具栏列表的组件。这工作得很好，除了工具栏类实现了IDisposable之外，manager类从不调用它管理的工具栏上的Dispose方法。这是一个bug。幸运的是，很容易找到一种变通方法:只需在每个工具栏上调用Dispose。不幸的是，这是不够的，因为工具栏类本身是有缺陷的:它不处理它所包含的控件(按钮、标签等)。同样，解决方案是释放工具栏包含的每个控件，但这一次不是那么容易，因为每个子控件都是不同的。
不管怎样，这只是一个具体的例子。我的观点是，您使用的任何库和组件都可能导致应用程序中的泄漏。

最后，我想补充一句，“是.NET框架泄露了!”这种说法是一种非常糟糕的立场，因为它意味着你必须对它敬而远之。即使.NET自己造成了泄漏，这也是一种例外的情况，您很少会遇到这种情况。


## 展示常见内存泄漏的原因

我已经列出了泄漏的主要来源，但我不想在这里停止。我认为如果我能用一个简单的例子来说明每一点，那么这篇文章将会更有用。那么，让我们以Visual Studio和dotTrace为例，浏览一些示例代码。同时，我将展示如何解决或避免每个泄漏。

projectX是使用CAB和MVP(模型-视图-演示者)模式构建的，这意味着GUI由工作区、视图和演示者组成。为了简单起见，我决定使用一个基本的Windows窗体应用程序和一组窗体。我甚至将为事件处理程序重用相同的示例。

当窗体被关闭并释放时，我们期望它从内存中释放，对吗?

下面我将展示我在上面列出的原因是如何阻止窗体被释放的。

下面是我创建的示例应用程序的主要形式:

这个主窗体可以打开不同的子窗体;每一个子窗体都可能导致单独的内存泄漏。

在本文末尾的参考资料部分，您将找到这个示例应用程序的源代码。


#### 静态引用

让我们先把明显的去掉。如果一个对象被一个静态字段引用，那么它将永远不会被释放。
对于单身人士来说也是如此。单例对象通常是静态对象，如果不是这样，它们通常是长期存在的对象。

这可能是显而易见的，但请记住，不仅直接引用是危险的。真正的危险来自间接引用。事实上，你必须注意引用的根。重要的是每个引用的根。如果根是静态的，那么引用下面的所有对象都将永远保持活动状态。

如上面图中的Object1是静态的，并且很可能是长期存在的，那么引用链下的所有其他对象都将在内存中保存很长时间。危险之处在于，链可能太长，以至于无法意识到链的根是静态的。如果您只关心一个深度级别，那么您将考虑Object3和Object4将在Object2消失时消失。当然，这是正确的，但是您需要考虑这样一个事实:它们可能永远不会消失，因为Object1使整个对象链都保持活动状态。

要非常小心各种各样的静态对象。如果可能，尽量避免。如果没有，请仔细注意静态对象和单例对象在内存中保存的对象。

还有一种特殊的危险是**静态事件**。我将在介绍一般事件之后再介绍它们。

#### 事件或“失效的监听器”问题

一个子窗体订阅主窗体的一个事件，当透明度改变时得到通知(EventForm.cs):

```csharp
mainForm.OpacityChanged += mainForm_OpacityChanged;
```

问题是OpacityChanged事件的订阅创建了一个从主窗体到子窗体的引用。

如您所见，MainForm保留了对EventForm的引用。在应用程序中打开的EventForm的每个实例都是这种情况。这意味着，当应用程序处于活动状态时，您将打开的所有子窗体都将保留在内存中，即使您不再使用它们。

这不仅将子表单保存在内存中，而且如果在关闭子表单之后更改不透明度(因为主窗体试图通知已订阅事件的子窗体)，还会导致异常。

最简单的解决方案是删除引用，让子窗体取消订阅主窗体的事件:

```csharp
Disposed += delegate { mainForm.OpacityChanged -= mainForm_OpacityChanged; };
```

这里有一个问题，因为MainForm对象在应用程序关闭之前一直是活动的。具有较短生存期的互连对象可能不会导致内存问题。任何独立的对象都会被垃圾收集器从内存中自动卸载。一个孤立的对象是由两个只相互引用的对象或一组没有任何外部引用的连接对象组成的。

另一种解决方案是使用基于弱引用的弱委托。我在关于事件和参考文献的帖子中提到了这个主题。网上有几篇文章演示了如何将其付诸实践。这里有一个很好的例子。您将发现的大多数解决方案都基于WeakReference类。您可以在MSDN. net中了解更多关于弱引用的信息。

请注意，在WPF中有一个解决方案，其形式是WeakEvent模式。

如果您使用CAB(复合UI应用程序块)或Prism(复合应用程序库)等框架，那么还有其他解决方案，分别是EventBroker和EventAggregator。如果需要，还可以使用自己的事件代理/聚合器/中介模式实现。

在静态或长生存期对象上的事件中缺少取消订阅的事件处理程序是一个问题,同理适用静态事件。

#### 静态事件

如：

```csharp
SystemEvents.UserPreferenceChanged += SystemEvents_UserPreferenceChanged;
```

这与前一种情况类似，只是这次我们订阅了一个静态事件。由于该事件是静态的，因此监听的窗体对象将永远不会被释放。