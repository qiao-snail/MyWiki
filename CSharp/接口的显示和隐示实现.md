# 接口的实现方式-显示/隐示
如果一个类继承了两个不同的接口，且这两个接口有共同的成员。如：
```CSharp
public interface I1
{
    string GetSome();
}

public interface I2
{
    string GetSome();
}
public class MyClass : I1, I2
{
    public string GetSome()
    {
        return "Some";
    }
}
```
当类实例在接口I1，I2中的实现一样时，可以任意调用：
```CSharp
MyClass c1 = new MyClass();

    I1 i1 = (I1) c1;
    I2 i2 = (I2) c1;

    c1.GetSome();
    i1.GetSome();
    i2.GetSome();
```
---
通常不同接口即使成员名称相同，返回值相同，实现的目的功能还是不一样的。如何显示区分不同接口呢。
### 接口显示实现
```CSharp
public class MyClass : I1, I2
{
    public string GetSome()
    {
        return "Some";
    }
    //接口成员的访问修饰符默认为public，且不能显示实现和修改，同样显示实现接口的类的成员也不可以有访问修饰符。
    string I1.GetSome()
    {
        return "I1.Some";
    }
}
```
i1.GetSome()的输出就是I1.Some

---
```CSharp
public class MyClass : I1, I2
{   
    string I1.GetSome()
    {
        return "I1.Some";
    }
}
```
如果只显示实现接口I1，报错，因为没有实现接口I2。

---
```CSharp
public class MyClass : I1
{   
    string I1.GetSome()
    {
        return "I1.Some";
    }
}
```
只显示实现接口I1，那么就不可以使用类实例来访问GetSome()方法
```CSharp
//错误
MyClass my1=new MyClass();
my.GetSome();
//正确
I1 i1=(I1) my1;
i1.GetSome();
//正确
I1 i1=new MyClass();
i1.GetSome();
```
---

所以当类实现多个有冲突的成员的接口时，显示使用接口可以解决这些冲突的接口成员。



