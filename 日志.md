
# 日志


  2020-03-16
  
## TCP

  TCP是传输层协议，TCP的传输是以字节段的形式发送，字节段的大小，其实取决于接收端的数据处理窗口大小。如果要保证数据的顺序行和不沾包，需要在应用层，自己定制协议，来保证。如HTTP协议。

- Autofac

  


---


   2020-03-17
  

## VS插件
   1.StyleCol  
   2.ReSharper.CommandLineTools
    
  
  

---

   
   2020-03-18
  

## MVC-Filter

  > 筛选器主要是特供了在Action执行前和后的添加逻辑的实现方式。筛选器使用了面向切口 _(AOP)_ 编程的方式,在管道中添加了新的切口，实现操作。  
   [参考地址](https://docs.microsoft.com/en-us/previous-versions/aspnet/gg416513(v=vs.98))
  
---

- Task.Wait()
  在UI线程中如果调用如下代码的Task.Wait()会出现死锁

  ```csharp
  public async Task RunAsync(){
    awiat Task.Run(()=>{
      //异步操作
    })
  }
  ```

   但是使用如下代码不会：  

```csharp

  public async Task RunAsync(){
    return Task.Run(()=>{
//异步操作
          })
  }
  ```

  或者是

 ```csharp

  public async Task RunAsyn(){
    await Task.Run(()=>{
      //异步操作
    }),ConfigureAwait(false);
  }
  ```

  
  

---

   2020-03-20
  

## Action委托

```CSharp
public MapperConfiguration(Action<IMapperConfigurationExpression> configure);

//如果一个委托只调用一个方法，可以使用
new MapperConfiguration(c=>Method(c));
//如果是需要调用多个可以加花括号来实现
new MapperConfiguration(c=>{
Method1(c);
Method2(c);
Method3(c);
});

```
    
  
  

  ---

  
   2020-03-24
  

## 方法的形参为父类的集合

当方法的形参为父类时，子类可以作为实参直接传递。

但是

当方法的形参为父类的**集合**时，子类集合不能作为实参传递。
因为子类可以转换为父类，但是子类集合不能转换为父类集合。

建议：

如果需要时，可以使用泛型，使用泛型方法，同时设置泛型类型继承自父类：

如：

```CSharp
public Method<T> DoMethod(List<T> list) where T:ParentClass{

}
//使用时：
DoMethod(new List<ChildClass>() );
```
    
  
  

  ---


   2020-03-26
  

## MySql索引

>索引可以包含一个或多个列的值，如果索引包含多个列的值，则列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。

根据数据结构可以分为3种：
 
 1. 哈希表

 2. 有序数组

 3. 搜索树（重点）


 ##  哈希索引

哈希表是一种以键-值（key-value）的方式存储数据的结构，我们只要输入待查找的值（即key），就可以找到其对应的值（即Value）。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置，即idx = Hash(key)。如果出现哈希冲突，就采用拉链法解决。

因为哈希表中存放的数据不是有序的，**因此不适合做区间查询，适用于只有等值查询的场景**。

## 有序数组

有序数组在等值查询和范围查询场景中的性能都非常优秀。用二分法就可以快速找到（时间复杂度为O(logN)）。但是如果要往中间插入一条数据，则必须挪动后面的所有记录，成本较高。因此，**有序数组只适用于静态存储引擎，即数据表一旦建立后不再会修改**。

## B+树索引（InnoDB）

使用B+树存储数据可以让一个查询尽量少的读磁盘，从而减少查询时磁盘I/O的时间。

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。
    
  
  

  ---


  
   2020-03-30

  

 ##  vscode 使用markdown编写时序图

 1. vscode插件：
  1.1 
  
  

---



   2020-04-01

  

 ##  C#扩展方法

* 如果扩展方法与该类型中定义的方法具有相同的签名，则扩展方法永远不会被调用。

* 在命名空间级别将扩展方法置于范围中。 例如，如果你在一个名为 Extensions 的命名空间中具有多个包含扩展方法的静态类，则这些扩展方法将全部由 using Extensions; 指令置于范围中。

扩展方法，同样可以扩展接口，这样所有实现该接口的类，自动拥有该方法


```csharp
public interface IInterfaceA{}
public class InterfaceExtension{
  public static ExtensionMethodA(this IInterfaceA,int i){
    console.writeline("ExtensionMethodA:"+i);
  }
}

```
  
  

  ---

  
   2020-04-10

  

 ## Entity Framework查看生成的sql语句


```csharp

context.DataBase.Log=Console.WriteLine;
//*这是一个委托，同理可以做日志输出*

```

[官网地址](https://docs.microsoft.com/en-us/ef/ef6/fundamentals/logging-and-interception)
  
  

---


  
   2020-04-13

  

 ## IIS CPU使用过高

 可能原因是静态字典变量，在多并发，即多线程的情况下导致。Dictionary类型只有当字典没有更改时，允许多线程并发访问。如果该字典有改动，且多线程访问，会出现排队，CPU升高问题。

 解决问题：
 
 1. 使用锁来规避该类问题。

 2. 使用ConcurrentDictionary线程安全字典来规避，使用该字典可以降低lock的范围，提升性能。

## lock Tips

lock影响范围应该尽量小，来提升程序性能。

lock读取的变量值，尽量存放到一个局部变量中，且lock的范围只包含读取值，其他的不用加锁。


## MVC异常处理的5种方法

MVC几种可行的方式来处理应用程序异常。

    Web.Config 文件中的 <customErrors> 结点
    MVC 的 HandleError 特性
    Controller.OnException 方法
    HttpApplication Application_Error 事件
    使用Stackify 的 Retrace 收集异常


[来源-简书](https://www.jianshu.com/p/a5204606588a)

  
  


---


  
   2020-04-14

  

 ## .NET 事件 内存泄露

首先需要明确一点事件是一种委托，委托由target属性来指向归属。即委托是由哪个对象引用了。当使用操作符+=时，其实了new了一个委托，该事件就和该对象产生了强关联。就会导致，事件对象不会被gc回收。即便已经事件的对象方法已经执行完毕。
只要事件的对象没有被回收，该事件就不会被回收，会一直占用内存。


原则1 **谁创建的对象，谁就有责任释放**
  
  

---

  
   2020-04-22

  

 ## Select和SelectMany

 Select是返回多个集合

 SelectMany是整理后返回一个集合
  
  

  ---

  
   2020-04-23

  

 ## Mysql索引

## 聚簇索引
 
 每个索引都会有个索引树，当索引树包含索引数据时，称之为聚簇索引。（主键索引即为聚簇索引）

 ## 索引回表

 当索引树不包含数据时，会现在当前索引树上找到索引值，再回到主键索引上找到数据（从普通索引树回到主键索引树搜索的过程就叫做回表）

 如：
 select * from user where name='BB'//name列设置了索引，会现在name这个索引树上找到id（主键）的值。
 再在主键索引上找到数据。(* 表示查找所有数据，需要回到主键上找到所有数据)

 执行流程：

 1. 选择使用 name 索引树；
 2. 找到索引树的第一层结点，由于 where 条件中'BB'的值小于第一层结点中关键字'CC'的值，索引进入到关键字'CC'的左子树中查找；
 3. 进入到第二层的叶子结点，找到关键字'BB'，由于叶子结点中存放了主键 id 的数据，所以返回'BB'中主键 id 的值 2；
 4. 根据主键 id=2，再去主键 id 的索引树中查找，找到 id=2 所对应的数据 R2；
 5. 在 name 索引树中继续向后查找，找到'BB'的下一个关键字'CC'，发现'CC'不等于 where 条件中的'BB'，所以结束查找。

## 覆盖索引

select * from user where name='BB' 需要回表。但是当索引树上包含了查找的数据时，不需要回表操作即为覆盖索引 如： select id from user where name='BB'； name索引树上包含了主键id的值。直接就获取了。这个操作减少了回表操作，会更高效。


## 联合索引

select name,age from user where name='BB'

因为name是有索引的，索引在name索引树上可以直接获取name的信息，但是同时也要获取age信息，此时name索引树上没有name信息，需要回表到主索引树上再获取age信息，进行了一次回表。

如果要避免本次的回表操作。可以使用联合索引。及name和age为同一索引。

但是需要知道联合索引有最左匹配原则：

```sql
select name,age from user where name = 'BB' and age = 33; # 在使用联合索引时，会依次匹配name列和age列。

select name,age from user where name = 'B%' and age = 33; # 在使用联合索引时，当匹配到name这一列的时候，由于name使用了like范围查找，因此后面不会再匹配age这一列了。

select name,age from user where age = 33; # 在使用联合索引时，由于联合索引的最左列为name列，而我们在where条件中匹配的是age列，因此不满足最左匹配原则，所以该条SQL会进行该联合索引的全表扫描。
```

  
  
  
----

  
   2020-05-11

  

 ## string.ToUpper()方法耗时耗资源

 * string是引用类型且不可变，每次修改都会创建一个新的string对象。所以当有多个string通过ToUpper方法来比较时，就会创建一倍以上的对象，增加了内存和时间消耗。

 优化方式：
 
 可以使用string.compare(string1,string2,StringComparison.OrdinalIgnoreCase)方法来对比实现。

 该方法是因为使用了ascii编码来对比实现，所以会高效。
  
  

  ---

   
   2020-05-14

  

 ## 协变和逆变

 * 当一个集合直接进行协变和逆变时，是不允许的。但是可以通过使用接口和out(协变) in(逆变) 关键字来实现。

 如 协变：

IEnumerable<Fruit> f=new List<Apple>();
其中IEnumerable是这样定义的：
public interface IEnumerable<out T> : System.Collections.IEnumerable

逆变：

[参考](https://blog.csdn.net/u010476739/article/details/106080975)

  
  

  ---

2020-05-27

## List扩容导致内存增大优化

List如果当前的容量不够时，会成倍的增加容量，导致内存也成倍的增加。即使只是新增了一个元素，也有可能翻倍容量。

所以优化需要手动优化容量
list1.Capacity = list1.Count;

---

2020-06-09

## 单例实现的几种方式

1. 双检锁
2. static cctor
3. Lazy<T>


[参考1](https://blog.csdn.net/fd2025/article/details/79711198)

---

2020-06-10

## linq 筛选去重操作：

```csharp
var result = myList.GroupBy(test => test.id)
                   .Select(grp => grp.First()).where(item=>item!=null)
                   .ToList();

```

---

2020-06-11

## 字符串判断是否相等


```csharp
 bool safeEqual (string a, string b) {
            if (a.Length != b.Length) {
                return false;
            }
            int equal = 0;
            for (int i = 0; i < a.Length; i++) {
                equal |= a[i] ^ b[i];//逻辑异或运算符^:如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。
                //按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1。
            }
            return equal == 0;
        }
    }

  ```


  ## 字符串驻留池

  使用驻留池可以使字符串相同的内容，共用一个托管堆地址。减少内存。当字符串相同时在编译时就已经默认实现了驻留池。但是当在运行时，默认是不会使用驻留池的。需要我们手动添加``string.Intern``来实现。


  ---


  2020-06-16

  ## foreach赋值异常

  foreach迭代中，不可对集合进行增删，但是其实对于值类型来说也是不允许修改的。但是对于引用类型是可以的。 


  ## async await 异常

  >[Async void methods have different error-handling semantics. When an exception is thrown out of an async Task or async Task method, that exception is captured and placed on the Task object. With async void methods, there is no Task object, so any exceptions thrown out of an async void method will be raised directly on the SynchronizationContext that was active when the async void method started. Figure 2 illustrates that exceptions thrown from async void methods can’t be caught naturally.](https://stackoverflow.com/questions/19865523/why-cant-i-catch-an-exception-from-async-code)



  在async方法中是可以再次catch到里面await的 async方法。但是在同步方法中是不能再次catch到await的async方法。

  ## 索引失效

  1. mysql 中索引列参与了函数运算会导致索引失效。需要特别注意的是隐式函数如类型转换，varchar列使用int数据查询（varcharcolumn1=1233);
  2. mysql 中使用了索引排序有可能会导致索引失效。
  3. 对索引列使用了计算（也算是函数）


**覆盖索引**

覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。
如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。


## DDD

数据实体分为贫血模型和充血模型。
1. 贫血模型，即实体中只包含了对应的属性，而不包含对应的行为，对应的行为放到了service层。
2. 充血模型，即service层很薄，几乎没有，实体不仅包含了对应的属性，相关的行为也放到了实体中，但是这样的后果就是实体会很复杂，有可能不同的实体会相互掺杂，且不耦合，不易扩展。

数据仓库也可分为读取操作在一个仓库完成，或者是增删改在一仓库中完成，查询相对来说会较多，较复杂，可单独出离出来在service层实现。这样也很好。

**聚合根，实体对象和值对象**

聚合根：领域中主要的对象。如电商中主要对象是订单。

实体对象：包含了一些行为的对象

值对象：简单对象，且一旦实现了就不再更改。如已付订单中的地址对象，就是一个值对象，订单一旦生成，就不可再更改地址。

通常情况下，对于聚合对象，使用工厂模式来创建。因为聚合对象通常交复杂，需要初始化许多辅助对象，辅助信息，所以这些封装后，不易出错，且简单可用。

*至于仓储应该放在基础层还是领域层，还是领域层只定义，基础层负责实现。一不影响性能，二不影响扩展。我认为都可以。*

---

2020-06-24

## C# 读取文件

可以使用FileStream流直接读取

```csharp
 var streamRead = new FileStream(filepath, FileMode.Open);
 byte[] pdfByte = new byte[streamRead.Length];
 streamRead.Read(pdfByte, 0, (int)streamRead.Length);
 //字节数组转换为base64字符串
 string base64String = Convert.ToBase64String(pdfByte, 0, pdfByte.Length, Base64FormattingOptions.None);
 streamRead.Close();
```

## JSON的时间戳转换为可空时间类型

如果c#定义时间类型为可空，那么Json的数值需要是null，不能是empty，否则会认为是无效的时间类型

---

2020-07-20

## XML反序列化
1. 读取XML文本信息

```csharp
if (!File.Exists(XmlConfigPath)) return null;
string xmlString = File.ReadAllText(XmlConfigPath);
```

2. 反序列化string为对象

```csharp
//方法1：使用xmlreader读取，再反序列化
XmlSerializer serializer = new XmlSerializer(typeof(MSGType));
MSGType resultingMessage = (MSGType)serializer.Deserialize(new XmlTextReader("yourfile.xml"));

//方法2：string转换为内存流，再序列化
MemoryStream memStream = new MemoryStream(Encoding.UTF8.GetBytes(inputString));
XmlSerializer serializer = new XmlSerializer(typeof(MSGType));
MSGType resultingMessage = (MSGType)serializer.Deserialize(memStream);

//方法3：使用stringreader转换为流，再次序列化
XmlSerializer serializer = new XmlSerializer(typeof(MSGType));
StringReader rdr = new StringReader(inputString);
MSGType resultingMessage = (MSGType)serializer.Deserialize(rdr);

```
3. 反序列为对象，可在对象使用xml特性标识该对象在xml结构中的元素
  * 标识根节点 `[XmlRoot("")]`
  * 标识普通元素节点 `[XmlElement("")]`
  * 标识集合元素节点`[XmlArrayItem("", IsNullable = false)]`
  等等


总结：
**xml反序列化需要将string转换为流，再使用反序列化方法，反序列化为一个对象**

## WPF Binding

在ComboBox中使用ItemsSource={Bidning Path/Source=''}是不一样的。

在ComboBox中如果指定了SelectedValuePath那么在设置SelectedValue时，会根据指定的Path来转换为对应的Item对象，通过该转换需要手动实现，但是如果不设置SelectedValuePath，仅设置SelectedValue，那么不需手动实现转换方法，就可以实现转换。


## StackPanel和DockPanel的区别：

The difference is that a StackPanel will arrange child elements into single line (either vertical or horizontally) whereas a DockPanel defines an area where you can arrange child elements either horizontally or vertically, relative to each other (the Dock property changes the position of an element relative to other elements within the same container. Alignment properties, such as HorizontalAlignment, change the position of an element relative to its parent element).

---

2020-07-23
## async Task.WhenAll

在async方法中，如果有多个异步方法，可以使用`task.WaitAll`来等待所有数据。但是在当前异步方法中，不能添加`await`关键字，可以使用`Task.WhenAll`方法添加关键字`await`来实现

---

2020-07-24

## EF批量插入

数据的批量插入是有阀值的，不是一次性将所有数据一次插入。当数据量较大时，可以分批次插入，一次插入耗时最少的最大数据。
同时关闭EF的上下文检测等方法。该方法也非常消耗性能。`context.Configuration.AutoDetectChangesEnabled = false;``context.Configuration.ValidateOnSaveEnabled = false;`

由差到好的插入方式：

* Call SaveChanges() once after ALL records.
* Call SaveChanges() after for example 100 records.
* Call SaveChanges() after for example 100 records and dispose the context and create a new one.
* Disable change detection（`context.Configuration.AutoDetectChangesEnabled = false;``context.Configuration.ValidateOnSaveEnabled = false;`）

[参考地址](https://stackoverflow.com/questions/5940225/fastest-way-of-inserting-in-entity-framework)

[EF混合使用SQL LINQ，对象](https://docs.microsoft.com/en-us/ef/core/querying/raw-sql)

---


2020-07-27

## Autofac 使用Keyed注册

```csharp
var builder = new ContainerBuilder();
builder.RegisterType<DerivedB>().Keyed<B>("first");
builder.RegisterType<AnotherDerivedB>().Keyed<B>("second");
builder.RegisterType<A>();
var container = builder.Build();

//使用
public class A
{
  IIndex<string, B> _b;

  public A(IIndex<string, B> b) { _b = b; }

  public void M()
  {
    var b = this._b["first"];
    b.DoSomething();
  }
}
```


---

 2020-07-29

## MSTest 单元测试

如果测试方法有固定入参的话，可以使用`[DataRow()]`特性来标记

如果测试方法中有相互调用的话，建议只在最后的方法中标记`[TestMethod]`，其他被调用的方法中移除该特性。这样可以顺利通过单元测试

[其他的数据入参测试](https://www.meziantou.net/mstest-v2-data-tests.htm)

---

2020-08-11

### XML序列化

使用xmlroot("")特性和xmlelement("")来关联属性和节点之间的关系，如果是集合的化，需要使用xmlarry("")和xmlarrayitem("")来关联

如：

```csharp
  [XmlArray("DeviceList")]
        [XmlArrayItem("Device", IsNullable = false)]
        public List<Device> Devices { get; set; }
```
对应的xml节点是：

```xml
 <DeviceList>
    <Device>
      <ID>202000609-100-012</ID>
      <Name>德卡</Name>
      <PortType>1</PortType>
      <Port>100</Port>
      <Baudrate>115200</Baudrate>
      <Permissions>1,2,3</Permissions>
      <Interval>2</Interval>
      <ISAutoRead>1</ISAutoRead>
    </Device>
  </DeviceList>

```
---

2020-08-12

Task.Delay和Thread.Sleep

反射加载程序集，创建类实例。

应用程序域概念


---

2020-08-17

### Autofac获取所有实现一个接口的对象

var classes = container.Resolve<IEnumerable<ISomeInterface>>();

### Autofac 扫描程序集获取所有注册实现接口的类的自动注册

```csharp
var assembly = Assembly.GetExecutingAssembly();

builder
    .RegisterAssemblyTypes(assembly)
    .AssignableTo<IQuery>()
    .AsImplementedInterfaces()
    .InstancePerRequest();

    //通过筛选自动注册

    builder.RegisterAssemblyTypes(yourAssembly)
       .Where(t => t.IsClass && t.Name.EndsWith("Query"))
       .As(t => t.GetInterfaces().Single(i => i.Name.EndsWith(t.Name)));
```

---

2020-08-27

### 判断集合是否为空
判断集合是否为空，不能只判断Count==0
还需要判断是否为空
如：
if (ysService.YousuuData?.Data?.Books?.Count == null || ysService.YousuuData?.Data?.Books?.Count == 0)
或者可以使用any方法
if (ysService.YousuuData?.Data?.Books?.Any() != true)

---

2020-08-28

### Log4NetIsInfoEnable一直是false

一般遇见该问题，通常是指没有启用Log4net，启用方式有以下几种：
* log4net.config文件要设置其属性为允许复制
* 在log4net的配置类添加特性`[assembly: log4net.Config.XmlConfigurator(ConfigFile = "log4net.config", Watch = true)]`,在dotnet core该特性好像不起作用中
* 添加Nuget包：`Microsoft.Extensions.Logging.Log4Net.AspNetCore`，在`CreateHostBuilder`类中注册log4net

```csahrp
  ConfigureLogging(logging =>
            {
                logging.ClearProviders();
                logging.AddConsole();
                logging.AddLog4Net("log4net.config");
            })

```

---

2020-09-04

### Blazor.Server 

**如果要注入的对象的生命周期和组件一样的话，就不能使用inject，必须手动解析来获取对象(ScopedServices)**


使用 `@inject` 或 `[Inject]` 特性注入到组件中的 DI 服务不在组件的范围内创建。 要使用组件的范围，必须使用 `GetRequiredService` 或 `GetService` 解析服务。 任何使用 `ScopedServices` 提供程序进行解析的服务都具有从同一范围提供的依赖关系。

```csharp
@page "/preferences"
@using Microsoft.Extensions.DependencyInjection
@inherits OwningComponentBase

<h1>User (@UserService.Name)</h1>

<ul>
    @foreach (var setting in SettingService.GetSettings())
    {
        <li>@setting.SettingName: @setting.SettingValue</li>
    }
</ul>

@code {
    private IUserService UserService { get; set; }
    private ISettingService SettingService { get; set; }

    protected override void OnInitialized()
    {
        UserService = ScopedServices.GetRequiredService<IUserService>();
        SettingService = ScopedServices.GetRequiredService<ISettingService>();
    }
}
```
### Blazor.Server中使用log
需要注意：

* 需要添加nuget包：`Microsoft.Extensions.Logging.Log4Net.AspNetCore`
* 在program.cs文件中IBuilder添加`.ConfigureLogging(logging =>
            {               
                logging.AddLog4Net("log4net.config", true);
            })`
* log4net.config的属性要设置为输出，同时要在其类的命名空间上添加特性`[assembly: log4net.Config.XmlConfigurator(ConfigFile = "log4net.config", Watch = true)]`


### Blazor组件可能会呈现两次获多次

当RenderModer为ServerPrerendered时，组件会先作为静态页面呈现。当浏览器和服务器建立连接后，会再次呈现，此时该页面为交互式。即：如果存在用于初始化组件的OnInitialized（Async）生命周期的方法。则该方法执行两次：

* 在静态预呈现组件时执行一次
* 在建立服务器连接后执行一次

### Blazor的render-model有三种模式，默认是使用ServerPrerendered：预编译成一个交互的html页面。而Static则是一个纯静态的html页面，不能执行页面交互

---

2020-09-10

rabbitmq不能自动发现队列，自动订阅消息。当前主要的方案是：发送方根据routingkey，发送数据到exchange，消费方则定义队列，绑定exhcange，决定消息进入哪个队列。接收消息。

---

2020-09-11

rabbitmq当多个消费者绑定到同一个队列时，只有一个消费者会收到消息，一次只有一个消费者可以收到消息。如果需要多个消费者都收到消息，需要给每个消费者生命一个队列。获取使用fant类型的exchange。

rabbitmq 当exchange没有绑定到队列时，消息会丢失。所以可以在发送者中定义好消息的exchange和queue。如果不想消息丢失，需要设置消息持久化。

rabbitmq 如果想要一个队列同时给多个消费者发送消息，只能使用Fanout类型的ExchangeType。可以给不同的消费者定义不同的exchange，如vipexchange，commonexchange等等，定义一个queue，指定exchange（设置ExchangeType为Fanout时，routingkey是无效的）


---

2020-09-14

rabbitmq如何保证消息不会丢失：

* 设置备用队列或者死信队列
* 设置消息ack手动确认和持久化。
* 确保发送消息前，队列已创建绑定好。

rabbitmq如果要修改exchange或者queue的配置需要删除已存在的队列重新设置。

---

2020-09-15

MySql中的GroupBy方法

GroupBy分组数据，如果直接输出字段的话，只会输出分组后第一行的数据。当对某一列使用函数（最大值，最小值，平均值等）只对当前列优化，不对行产生影响。

[abbitMQ / AMQP: single queue, multiple consumers for same message?](https://stackoverflow.com/questions/10620976/rabbitmq-amqp-single-queue-multiple-consumers-for-same-message#comment13764642_10620976)
一个队列，多个消费者获取相同的消息。本质上是不能实现的。不同消费者相同的队列，只会交替的获取消息。如果想实现该需求，可以对不同消费者定义不同的队列。使用direct或Topic来绑定到exchange。
[RabbitMQ: persistent message with Topic exchange](https://stackoverflow.com/questions/6148381/rabbitmq-persistent-message-with-topic-exchange)
消息持久化，必须是exchange和队列都创建好后才可以。否则会丢失数据。exchange并不保存消息，队列才会保存消息。所以要么是在management中创建绑定好消息，要么是先启动消费者，再启动生产者。但是通常是两者结合来使用。
[RabbitMQ:Thread Channel Connection](https://stackoverflow.com/questions/10407760/is-there-a-performance-difference-between-pooling-connections-or-channels-in-rab)

---

2020-09-16

Mysql使用PowerShell如果没有指定环境变量需要在指定路径内使用命令（指定路径在mysqld.exe目录下）

NETCORE 使用EFCore和MySql只能在NET CORE类型下使用，不能再Standard类型下使用，修改类型可以再csproj的文件中修改TargetFramework修改。

在NET Core中不能直接使用EF Core来生成对应脚手架(包含Context和Model的文件)，需要使用命令`dotnet ef dbcontext scaffold "Server=localhost;Database=newxs;User=root;Password=wyygmxjy;TreatTinyAsBoolean=true;" "Pomelo.EntityFrameworkCore.MySql"`生成对应的类文件
如果使用该命令提示dotnet core命令无效，需要导入该命令`dotnet tool install --global dotnet-ef`

[官网参考](https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/cli/dotnet#other-target-frameworks)列出了ef相关的命令。

---

2020-09-25

MySql中的快照读，幻读，可重复读。

* 可重复读：别的事务的提交，对当前事务的查询结果，不会产生影响；（事务在一开始的时候，会生成一个快照）
*  快照读
　　单纯的select操作，不包括上述 select ... lock in share mode, select ... for update。　　　　

　　Read Committed隔离级别：每次select都生成一个快照读。

　　Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。


* mysql有两种读数据的模式，一种是当前读，一种是快照读。
  
快照读的意思是，数据有多个版本， 当事务并发执行时， 某一事务读取的数据来自其中一个版本（快照）。下面举例说明（Repeatable Read级别）：

| 时间 | 事务A                                             | 事务B                                   |
| ---- | ------------------------------------------------- | --------------------------------------- |
| 0    | set autocommit=0 （开始事务）                     | set autocommit=0（开始事务）            |
| 1    | selcect * from table_a where name=‘abc’ (返回空） |
| 2    |                                                   | insert into table_a(name) values(‘abc’) |
| 3    |                                                   | commit                                  |
| 4    | selcect * from table_a where name=‘abc’ (仍然空） |
|      |                                                   |
可以看到，两个并发执行的事务， 即使B插入并提交了数据， A仍然看不到，因为A读的还是快照。

* 时间点
事务在查询的时候，是查找某一个快照的，那么怎么确定查的是哪一个快照呢？ **这个时间点，就是事务第一次查询时的时间，在这个时间点前面提交的数据（其他事务提交），都可以查询到。**
像上面那个例子，就是因为事务A第一次查询时间早于事务B提交时间，所以查询不到aaa的数据。下面再看一次例子：

| 时间 | 事务A                                                 | 事务B                                   |
| ---- | ----------------------------------------------------- | --------------------------------------- |
| 0    | set autocommit=0 （开始事务）                         | set autocommit=0（开始事务）            |
| 1    |                                                       | insert into table_a(name) values(‘bbb’) |
| 2    |                                                       | commit                                  |
| 3    | selcect * from table_a where name=‘bbb’ (返回了数据） |
|      |                                                       |
可以看到事务A和B同时开始，但由于事务A的第一次查询时间晚于B， 所以能查到B提交的数据。
如果在事务中使用了DML更新/删除了其他事务提交的数据，那么这些数据会对当前事务可见，可以查询到，注意仅仅是被影响到的数据，其他在这之前提交的数据一样查询不到。


[RabbitMQ断开重连机制](https://stackoverflow.com/questions/12499174/rabbitmq-c-sharp-driver-stops-receiving-messages)

---

2020-09-28

### Identity Server4.0
 
 Identity Server主要提供了两项服务

 1. 基于OpenId的身份认证
 2. 基于OAuth2.0的授权
（OpenId是用来身份认证的，OAuth是用来授权的）


Identity Server解决了哪些问题：

* 集中认证和授权
* 单点登录和授权
* 支持Web，移动和桌面应用

Identity Server的特性：

* 认证即服务
* Api访问控制
* 第三方登录
* 灵活定制
  
---
2020-09-29

### Identity Server4.0 JWTToken认证

JWT的的Token获取后，存在客户端，每次客户端请求都会带上这个Token。这个Token是自验证的。Token分为三个部分，header，payload，Signature。当服务端拿到这个Token后，会根据前两个值，使用加密算法生成Signature。将这个Signature和Token中的Signature对比。一致则合法，否则不合法。

且JWT是和语言无关的

[参考](https://zhuanlan.zhihu.com/p/193090304)

----

2020-10-12

C# List中某一项赋值，如果直接修改其简单属性字段是可以的。
但是如果直接赋值更新某一项则列表中的项是不会修改的。
如：
var find=List.FirstOrDefault(l=>l.Property=="ddss");
find=new Object();
List中的该项是不会改变的。因为find是一个地址拷贝。此时再次赋值，则将该地址指向了一个新对象，不再指向集合中的项
使用下标可是可以的。
var findIndex=List.FindIndex(l=>l.Property=="ddss");
if(findIndex!=-1){
  List[findIndex]=new Object();
}
直接将地址指向新对象

----

2020-10-22

C#类库中若想在日志输出代码的行号，需要将pdb文件和dll文件放在同一目录。

Oauth2.0的ClientId和ClientSecret用来标识Client。该数据是Client向认证服务器注册，认证服务器返回的Client标识。认证服务器根据这两个字段判断Client的真实身份

---

2020-10-23

输出纯净的XML格式的字符串，需要如下设置

```csharp

  public string SerializeToString<T>(T value)
    {
        var emptyNamespaces = new XmlSerializerNamespaces(new[] { XmlQualifiedName.Empty });
        var serializer = new XmlSerializer(value.GetType());
        var settings = new XmlWriterSettings();
        settings.Indent = true;
        settings.OmitXmlDeclaration = true;

        using (var stream = new StringWriter())
        using (var writer = XmlWriter.Create(stream, settings))
        {
            serializer.Serialize(writer, value, emptyNamespaces);
            return stream.ToString();
        }
    }

```

---

2020-10-28

AutoMapper的实例Mapper只能有一个。对于在多个不同类库的地方注册使用，可以将AutoMapper拆分成两部分，第一步：先添加ExpresionAcion。第二步：再次创建Mapper实例。


---

2020-10-30
Core注入手动解析

```csharp
private readonly IServiceScopeFactory scopeFactory;

    public MyHostedService(IServiceScopeFactory scopeFactory)
    {
        this.scopeFactory = scopeFactory;
    }

    public void DoWork()
    {
        using (var scope = scopeFactory.CreateScope())
        {
            var dbContext = scope.ServiceProvider.GetRequiredService<MyDbContext>();
            …
        }
    }

```

DotNet Core自带的依赖注入还可以使用参数注入

```csharp
public void GetDependencyObject([FromService] ISomeService service){

}

```

---

2020-11-02

DotNetCore配置实现：
IConfigurationBuilder利用注册在它上面的所有IConfigurationSource提供的IConfigurationProvider读取原始配置数据并创建出相应的IConfiguration对象


### in out ref 

* `ref` 修饰符，指定参数由引用传递，可以由调用方法读取或写入。
* `out` 修饰符，指定参数由引用传递，必须由调用方法写入。
* `in` 修饰符，指定参数由引用传递，可以由调用方法读取，但不可以写入。

`in` 修饰符的使用对于复杂结构体来说，避免了在多次传参时，多次复制结构体，浪费内存的问题。使其按照引用类型复制。但是是只读的。

使用 in 参数，有助于明确表明此参数不可修改的意图。
当只读结构体（readonly struct）的大小大于 IntPtr.Size [3] 时，出于性能原因，应将其作为 in 参数传递。
不要将一般（非只读）结构体作为 in 参数，因为结构体是可变的，反而有可能对性能产生负面影响，并且可能产生晦涩难懂的行为。

---

2020-11-04

Json本质是字典类型的字符串。所以可以将其转换成字典类型，或者准换成JObject类型，该类型支持字典操作

JObject json1 = JObject.Parse(JsonString);


---

2020-11-09

IServiceProdvice的依赖注入和使用

对于单例和瞬时注入的依赖可以直接使用

var serviceProvider = app.ApplicationServices;

var service = serviceProvider.GetRequiredService<IHelloService>();
来获取实例。
但是队列范围注册来说却是获取不到实例的。
只能通过IServiceProvider子级才能解析注入的Scope实例，因此要从根本上解决通过属性去获取到注入Scope实例，我们还需手动创建子级才可，如下：

var manualScope = app.ApplicationServices.CreateScope();

var service = manualScope.ServiceProvider.GetRequiredService<IHelloService>();
service.SayHello();

* 属性获取的是根部的IServiceProvider即（root IServiceProvider），而以方法参数传入的则是根部的孩子（child of the root）。

* 属性需创建子级IServiceProvider才可解析Scope服务

HTML重定向状态码
* 301 永久重定向 客户端可以缓存该响应并重用
* 302 临时重定向
  
---

2020-11-11

AutoMapper的自定义转换，比如需要将A中的Code准换为B的Value。两者的类型不一致。那么可以使用ResolveUsing来实现。

```csharp
//定义准换辅助类
public class CustomResolver : IValueResolver<Source, Destination, int>
{
	public int Resolve(Source source, Destination destination, int member, ResolutionContext context)
	{
        return source.Value1 + source.Value2;
	}
}

new MapperConfiguration(cfg =>
   cfg.CreateMap<Source, Destination>()
	 .ForMember(dest => dest.Total, opt => opt.MapFrom<CustomResolver>()));

   定义准换关系是使用辅助类
```

---

2020-11-12

C# List中判断不为空，且存在元素时，可以使用简写方式 

!List.IsNullOrEmpty()

List?.Any()==true

WinForm中Label的自动换行实现：

```csharp

myLabel.MaximumSize = new Size(100, 0);
myLabel.AutoSize = true;

```

DotNet Core实现异常可以使用UseExceptionHandler中间件来简化实现方式。规避将错误信息直接展示给用户

定义一个error路由的controller

```csharp
 [Route("error")]
    public class ErrorController : Controller
    {
        [HttpGet]
        public IActionResult Index()
        {
          //通过HttpContext获取异常信息
            var feature = HttpContext.Features.Get<IExceptionHandlerPathFeature>();
            if (feature != null)
            {
                string err;
                var req = HttpContext.Request;
                var ip = HttpContext.Connection.RemoteIpAddress.MapToIPv4().ToString();
                switch (feature.Error)
                {
                  //筛选错误类型
                    case DbUpdateConcurrencyException ex:
                        err = $"异常源：{ex.Source}，异常类型：{ex.GetType().Name}，\n请求路径：{req.Scheme}://{req.Host}{HttpUtility.UrlDecode(req.Path)}，客户端用户代理：{req.Headers["User-Agent"]}，客户端IP：{ip}\t{ex.InnerException?.Message}\t";
                        LogManager.Error(err, ex);
                        break;
                    case DbUpdateException ex:
                        err = $"异常源：{ex.Source}，异常类型：{ex.GetType().Name}，\n请求路径：{req.Scheme}://{req.Host}{HttpUtility.UrlDecode(req.Path)}，客户端用户代理：{req.Headers["User-Agent"]}，客户端IP：{ip}\t{ex?.InnerException?.Message}\t";
                        LogManager.Error(err, ex);
                        break;
                    case AggregateException ex:
                        LogManager.Debug("↓↓↓" + ex.Message + "↓↓↓");
                        ex.Handle(e =>
                        {
                            LogManager.Error($"异常源：{e.Source}，异常类型：{e.GetType().Name}，\n请求路径：{req.Scheme}://{req.Host}{HttpUtility.UrlDecode(req.Path)}，客户端用户代理：{req.Headers["User-Agent"]}，客户端IP：{ip}\t", e);
                            return true;
                        });
                        break;
                    case NotFoundException ex:
                        Response.StatusCode = 404;
                        return Request.Method.ToLower().Equals("get") ? (ActionResult)View("Index") : Json(new
                        {
                            StatusCode = 404,
                            Success = false,
                            ex.Message
                        });
                    default:
                        LogManager.Error($"异常源：{feature.Error.Source}，异常类型：{feature.Error.GetType().Name}，\n请求路径：{req.Scheme}://{req.Host}{HttpUtility.UrlDecode(req.Path)}，客户端用户代理：{req.Headers["User-Agent"]}，客户端IP：{ip}\t", feature.Error);
                        break;
                }
            }
            Response.StatusCode = 503;
            if (Request.Method.ToLower().Equals("get"))
            {
                return View();
            }
            return Json(new
            {
                StatusCode = 503,
                Success = false,
                Message = "服务器发生错误！"
            });
        }
    }
```
注册中间件

app.UseExceptionHandler("/error");


JWT 的认证是发生在Client和Agent之间。通常来说就是浏览器或APP和服务器之间。服务器生成secret，并返回给Agent。Agent的每次请求都带上这个secrent和认证方式{"alg": "HS256","typ": "JWT"}。服务器每次都会将json对象加密和secret对比来判断，用户的合法和认证。JWT是在OAuth授权之后的操作。和AuthorizationServer没有关系。


关于Token的认证其实可以多众实现方式的。JWT的实现是自认证的一种，不需要和认证服务或数据库打交道。

---

2020-11-16

### 信号量同步

`AutoResetEvent`:表示线程同步事件在一个等待线程释放后收到信号时自动重置。 在线程外，通过标记来控制线程内的执行。

`AutoResetEvent.WaitOne()`挂起等待，等待信号的释放。获取信号后再执行之后的语句

`AutoResetEvent.Set()`线程外给线程释放信号，让线程之后的语句继续执行。

---

2020-12-23

*DotNetCore*

`StartUp`主要功能：中间件和服务的注册。
`StartUp`可以依据约定的形式来实现：类名包含StartUp，实现方法：
```csharp
public void ConfigureServices(IServiceCollection servives);
    public void Configure(IApplicationBuidler app);
//中间件和服务的注册分别实现在Configure方法和ConfigureServices方法中
//中间件的注册也决定了HTTP请求管道的处理顺序和处理逻辑
```
---

2020-12-25

DotNet Core中依赖注入

* `IServiceCollection`  负责注册
* `IServiceProvider`  负责注册

```csharp
//通过默认的 ServiceCollection（在Microsoft.Extensions.DependencyInjection命名空间下）有三个方法：
var serviceCollection = new ServiceCollection()
  .AddTransient<ILoginService, EFLoginService>()
  .AddSingleton<ILoginService, EFLoginService>()
  .AddScoped<ILoginService, EFLoginService>();
  
  ```
  同时还有一个`AddHostedService`属于 `Microsoft.Extensions.Hosting.Abstractions`
  也可以实现注册，该注册时`Transmit`。用于需要长时间后台允许的服务(实现`IHostedService`接口或`BackgroundService`的类)，生命周期起始于`Start`方法，结束于`Stop`放法

  [什么是托管服务](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-5.0&tabs=visual-studio)
  
  ---

  2020-12-31

  Newtonsoft.Json.Linq.JObject jobject = (Newtonsoft.Json.Linq.JObject)Newtonsoft.Json.JsonConvert.DeserializeObject(jsonText);
  此jobject是键值对，可以通过下标key来获取值。也可以通过多次调用key值来获取层级下的值
  如：
   string output_type = jobject["output"]["type"].ToString();//"image/

---

2020-01-04

DotNetCore中的Filter和Middleware是完全不一样的两个概念。
Filter是在MVC中独有的。允许在请求处理管道中(Middleware)的某一个阶段之前或之后执行自定义的代码。不同的Filter对应着请求处理管道的不同阶段(不同的Middleware)

在MVC中内建的Filter有如下：
* ActionFilters 在Acton方法的执行前和执行后执行。
* AuthorizationFlters 在请求处理管道的开始处被执行，主要来获取用户的凭证信息，来验证用户是否被授权。
* ResourceFilters 在Authorizaton和模型绑定之前被执行。可以实现一些缓存逻辑
* ExceptionFilters 捕获请求处理管道中的所有异常，实现一些自定义的异常处理

[Filter官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0)

由于在ASP.NET Core 3.0中，app.UseMvc被app.UseRouting和app.UseEndpoints替代

---
2020-01-07

如果使用ABP时指定Tired(分层)在App 类型中那么CLI会创建分层解决方案. 分层结构的目的是将Web应用程序和HTTP API部署到不同的服务器比之前的项目多了个Api.Host

---

2020-01-11

DotNetCore中的RazorPages和MVC是不一样的。RazorPages简化了Controller和Model的构建。与使用控制器和视图相比，Razor Pages可以使以页面为中心的方案的编码更容易且效率更高。
[RazorPages](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio)

同样RazorPages的路由可以在页面中匹配。
在ConfigService方法中注册该功能services.AddRazorPages();
在Config中匹配路由

```csharp
 public void ConfigureServices(IServiceCollection services)
    {
        services.AddRazorPages();
    }
   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
      app.UseRouting();
     app.UseEndpoints(endpoints =>
        {
            endpoints.MapRazorPages();
        });
    }
```

---

2020-01-12

**ABP的API** 
>创建应用程序服务后, 通常需要创建API控制器以将此服务公开为HTTP(REST)API端点. 通常API控制器除了将方法调用重定向到应用程序服务并使用[HttpGet],[HttpPost],[Route]等属性配置REST API之外什么都不做.

但是ABP可以按照惯例 自动 将你的应用程序服务配置为API控制器. 大多数时候你不关心它的详细配置,但它可以完全被自定义。

即ABP可以将应用程序服务的方法自动映射为API。

应用程序服务只要实现了`IRemoteService` 接口。ABP就会将方法映射为API。(`ICRUDAppService`继承`IRemoteService`)。对于应用程序服务的方法可以使用`RemoteService`特性详细设置

DDD中实体定义在领域层，但是ModelToSQLTable需要在对应的ORM层中实现，因为每个ORM的实现规则可能不一样，所以最好是分开，一处定义实体，一处约定规则。
对于规则的实现，建议使用扩展方法，如此可以在一个对象方法中，一次实现，不用多次new对象后，再调用方法。

*一个对象如果需要序列化，那么必须有无参的构造函数，建议修饰符为private，这样在代码中正常创建时，需要有参的构造函数，不受影响。*
>任何Serializer类都需要无参数的构造函数，因为在反序列化它的过程中会创建一个空的新实例，然后它会复制从序列化数据中获取的每个公共属性。
如果要避免创建不带参数的构造函数，则可以轻松地将其私有化。

---

2020-01-19

ABP依赖注入，可以按照约定自动实现依赖注入。
需要注意的是，在应用程序层，自动注入的实现类必须实现ApplicationService（这是一个空类，只是为了实现注入，不包含任何方法和属性），对应的应用程序实现类的接口，则不是必须实现IApplicationService的接口的。需要注意的是，需要命名一致。

如果要手动注册的话，可以在ConfigureServices方法中用IServiceProvider来指定接口和实现的关系

```csharp
context.Services.AddTransient<Intervace>(sq => sq.GetService<ImpClass>());
```

---

2020-02-02

DotNetCore中的依赖注入，如果需要注入多个实例，仅使用构造函数注入，会导致构造函数的参数过多、使用属性注入的话，有些实例可能在该次执行中用不到但是也Resolve了。推荐将IServiceProvider获取，根据需要自己来Resolve对象。

```csharp
public class Demo1{
  private IServiceProvider _serviceProvider
  public Demo1(IServiceProvider serviceProvider){
        _serviceProvider=serviceProvider;
  }

  public void Method1<T>(T t){
   var dd= _serviceProvider.GetRequiredService<T>()
  }
}

```

在.NET Core中DI的核心分为两个组件：`IServiceCollection`和 `IServiceProvider`。
* `IServiceCollection` 负责注册
* `IServiceProvider` 负责提供实例


Use、Map，Run方法常用来一起构建 HTTP Pipeline 管道
`Use`
该方法将会执行一个委托，然后将 交接棒 传给Pipeline的下一个中间件，因该方法短暂拥有 交接棒，所以该方法可用于 短路操作。
`Run`
该方法会执行委托并返回结果。
`Map`
该方法将有条件地执行委托并返回结果。

*你可以使用Use，Run和Map配置HTTP管道。Use方法可以使管道短路（即，可以不调用下一个请求委托）。Run方法是一个约定， 并且一些中间件组件可能暴露在管道末端运行的Run [Middleware]方法。Map*扩展用作分支管道的约定。映射根据给定的请求路径的匹配来分支请求流水线，如果请求路径以给定路径开始，则执行分支*

---

2021-02-22
路由作用：路由负责匹配传入的 HTTP 请求，然后将这些请求发送到应用的可执行终结点。

终结点：
MapGet 方法用于定义终结点。 终结点可以：
通过匹配 URL 和 HTTP 方法来选择。
通过运行委托来执行。

UseRouting: Matches request to an endpoint.

UseEndpoints: Execute the matched endpoint.

```csharp
╔══════════════════════════════════════════╦═══════════════════════════════════════╗
║             app.UseRouting()             ║          app.UseEndPoints()           ║
╠══════════════════════════════════════════╬═══════════════════════════════════════╣
║               Find Endpoint              ║           Execute Endpoint            ║
║                                          ║                                       ║
║  Adds route matching to the middleware   ║  Adds endpoint execution to the       ║
║  pipeline. This middleware looks at the  ║  middleware pipeline.                 ║
║  set of endpoints defined in the app,    ║  It runs the delegate associated      ║
║  and selects the best match based        ║  with the selected endpoint.          ║
║  on the request.                         ║                                       ║
║                                          ║                                       ║
╚══════════════════════════════════════════╩═══════════════════════════════════════╝
```